/**
 * Copyright (c) 2015-present, Yuanyan Cao. All rights reserved.
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Fastfs = require('../fastfs');
var ModuleCache = require('../ModuleCache');
var Promise = require('promise');
var _ = require('underscore');
var crawl = require('../crawlers');
var debug = require('debug')('DependencyGraph');
var isAbsolutePath = require('absolute-path');
var path = require('path');
var util = require('util');

var DependencyGraph = (function () {
  function DependencyGraph(_ref) {
    var roots = _ref.roots;
    var platform = _ref.platform;
    var preferNativePlatform = _ref.preferNativePlatform;
    var ignoreFilePath = _ref.ignoreFilePath;
    var providesModuleNodeModules = _ref.providesModuleNodeModules;

    _classCallCheck(this, DependencyGraph);

    this._roots = roots;
    this._platform = platform;
    this._preferNativePlatform = preferNativePlatform;
    this._providesModuleNodeModules = providesModuleNodeModules;
    this._ignoreFilePath = ignoreFilePath || function () {};

    this._hasteMap = Object.create(null);
    this._immediateResolutionCache = Object.create(null);
    this.load();
  }

  _createClass(DependencyGraph, [{
    key: 'load',
    value: function load() {
      var _this = this;

      if (this._loading) {
        return this._loading;
      }

      var startTime = new Date();
      var allRoots = this._roots;
      this._crawling = crawl(allRoots, {
        ignore: this._ignoreFilePath,
        exts: ['js', 'json']
      });

      this._crawling.then(function (files) {
        return console.log('Crawl:', new Date() - startTime + 'ms');
      });

      this._fastfs = new Fastfs(this._roots, {
        ignore: this._ignoreFilePath,
        crawling: this._crawling
      });

      this._fastfs.on('change', this._processFileChange.bind(this));

      this._moduleCache = new ModuleCache(this._fastfs);

      this._loading = Promise.all([this._fastfs.build().then(function () {
        return _this._buildHasteMap();
      })]);

      return this._loading;
    }
  }, {
    key: 'resolveDependency',
    value: function resolveDependency(fromModule, toModuleName) {
      var _this2 = this;

      if (fromModule._ref) {
        fromModule = fromModule._ref;
      }

      var resHash = resolutionHash(fromModule.path, toModuleName);

      if (this._immediateResolutionCache[resHash]) {
        return Promise.resolve(this._immediateResolutionCache[resHash]);
      }

      var cacheResult = function cacheResult(result) {
        _this2._immediateResolutionCache[resHash] = result;
        return result;
      };

      var forgive = function forgive() {
        console.warn('Unable to resolve module %s from %s', toModuleName, fromModule.path);
        return null;
      };

      if (!this._isNodeModulesDir(fromModule.path) && toModuleName[0] !== '.' && toModuleName[0] !== '/') {
        return this._resolveHasteDependency(fromModule, toModuleName)['catch'](function () {
          return _this2._resolveNodeDependency(fromModule, toModuleName);
        }).then(cacheResult, forgive);
      }

      return this._resolveNodeDependency(fromModule, toModuleName).then(cacheResult, forgive);
    }
  }, {
    key: 'getOrderedDependencies',
    value: function getOrderedDependencies(entryPath) {
      var _this3 = this;

      return this.load().then(function () {
        var absPath = _this3._getAbsolutePath(entryPath);

        if (absPath == null) {
          throw new NotFoundError('Could not find source file at %s', entryPath);
        }

        var absolutePath = path.resolve(absPath);

        if (absolutePath == null) {
          throw new NotFoundError('Cannot find entry file %s in any of the roots: %j', entryPath, _this3._roots);
        }

        var entry = _this3._moduleCache.getModule(absolutePath);
        var deps = [];
        var visited = Object.create(null);
        visited[entry.hash()] = true;

        var collect = function collect(mod) {
          deps.push(mod);
          return mod.getDependencies().then(function (depNames) {
            return Promise.all(depNames.map(function (name) {
              return _this3.resolveDependency(mod, name);
            })).then(function (dependencies) {
              return [depNames, dependencies];
            });
          }).then(function (_ref2) {
            var _ref22 = _slicedToArray(_ref2, 2);

            var depNames = _ref22[0];
            var dependencies = _ref22[1];

            var p = Promise.resolve();
            dependencies.forEach(function (modDep, i) {
              if (modDep == null) {
                debug('WARNING: Cannot find required module `%s` from module `%s`', depNames[i], mod.path);
                return;
              }

              p = p.then(function () {
                if (!visited[modDep.hash()]) {
                  visited[modDep.hash()] = true;
                  return collect(modDep);
                }
                return null;
              });
            });

            return p;
          });
        };

        return collect(entry).then(function () {
          return Promise.all(deps.map(function (dep) {
            return dep.getPlainObject();
          }));
        });
      });
    }
  }, {
    key: '_getAbsolutePath',
    value: function _getAbsolutePath(filePath) {
      if (isAbsolutePath(filePath)) {
        return filePath;
      }

      for (var i = 0; i < this._roots.length; i++) {
        var root = this._roots[i];
        var absPath = path.join(root, filePath);
        if (this._fastfs.fileExists(absPath)) {
          return absPath;
        }
      }

      return null;
    }
  }, {
    key: '_resolveHasteDependency',
    value: function _resolveHasteDependency(fromModule, toModuleName) {
      var _this4 = this;

      toModuleName = normalizePath(toModuleName);

      var p = fromModule.getPackage();
      if (p) {
        p = p.redirectRequire(toModuleName);
      } else {
        p = Promise.resolve(toModuleName);
      }

      return p.then(function (realModuleName) {
        var dep = _this4._hasteMap[realModuleName];

        if (dep && dep.type === 'Module') {
          return dep;
        }

        var packageName = realModuleName;

        while (packageName && packageName !== '.') {
          dep = _this4._hasteMap[packageName];
          if (dep && dep.type === 'Package') {
            break;
          }
          packageName = path.dirname(packageName);
        }

        if (dep && dep.type === 'Package') {
          var _ret = (function () {
            var potentialModulePath = path.join(dep.root, path.relative(packageName, realModuleName));
            return {
              v: _this4._loadAsFile(potentialModulePath, fromModule, toModuleName)['catch'](function () {
                return _this4._loadAsDir(potentialModulePath, fromModule, toModuleName);
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }

        throw new Error('Unable to resolve dependency');
      });
    }
  }, {
    key: '_redirectRequire',
    value: function _redirectRequire(fromModule, modulePath) {
      return Promise.resolve(fromModule.getPackage()).then(function (p) {
        if (p) {
          return p.redirectRequire(modulePath);
        }
        return modulePath;
      });
    }
  }, {
    key: '_resolveNodeDependency',
    value: function _resolveNodeDependency(fromModule, toModuleName) {
      var _this5 = this;

      if (toModuleName[0] === '.' || toModuleName[1] === '/') {
        var potentialModulePath = isAbsolutePath(toModuleName) ? toModuleName : path.join(path.dirname(fromModule.path), toModuleName);
        return this._redirectRequire(fromModule, potentialModulePath).then(function (realModuleName) {
          return _this5._loadAsFile(realModuleName, fromModule, toModuleName)['catch'](function () {
            return _this5._loadAsDir(realModuleName, fromModule, toModuleName);
          });
        });
      } else {
        return this._redirectRequire(fromModule, toModuleName).then(function (realModuleName) {
          var searchQueue = [];
          for (var currDir = path.dirname(fromModule.path); currDir !== '/'; currDir = path.dirname(currDir)) {
            searchQueue.push(path.join(currDir, 'node_modules', realModuleName));
          }

          var p = Promise.reject(new Error('Node module not found'));
          searchQueue.forEach(function (potentialModulePath) {
            p = p['catch'](function () {
              return _this5._loadAsFile(potentialModulePath, fromModule, toModuleName);
            })['catch'](function () {
              return _this5._loadAsDir(potentialModulePath, fromModule, toModuleName);
            });
          });

          return p;
        });
      }
    }
  }, {
    key: '_loadAsFile',
    value: function _loadAsFile(potentialModulePath, fromModule, toModule) {
      var _this6 = this;

      return Promise.resolve().then(function () {

        var file = undefined;
        if (_this6._fastfs.fileExists(potentialModulePath)) {
          file = potentialModulePath;
        } else if (_this6._platform != null && _this6._fastfs.fileExists(potentialModulePath + '.' + _this6._platform + '.js')) {
          file = potentialModulePath + '.' + _this6._platform + '.js';
        } else if (_this6._preferNativePlatform && _this6._fastfs.fileExists(potentialModulePath + '.native.js')) {
          file = potentialModulePath + '.native.js';
        } else if (_this6._fastfs.fileExists(potentialModulePath + '.js')) {
          file = potentialModulePath + '.js';
        } else if (_this6._fastfs.fileExists(potentialModulePath + '.json')) {
          file = potentialModulePath + '.json';
        } else {
          throw new UnableToResolveError(fromModule, toModule, 'File ' + potentialModulePath + ' doesnt exist');
        }

        return _this6._moduleCache.getModule(file);
      });
    }
  }, {
    key: '_loadAsDir',
    value: function _loadAsDir(potentialDirPath, fromModule, toModuleName) {
      var _this7 = this;

      return Promise.resolve().then(function () {
        if (!_this7._fastfs.dirExists(potentialDirPath)) {
          throw new Error('Invalid directory ' + potentialDirPath);
        }

        var packageJsonPath = path.join(potentialDirPath, 'package.json');
        if (_this7._fastfs.fileExists(packageJsonPath)) {
          return _this7._moduleCache.getPackage(packageJsonPath).getMain().then(function (main) {
            return _this7._loadAsFile(main, fromModule, toModuleName)['catch'](function () {
              return _this7._loadAsDir(main, fromModule, toModuleName);
            });
          });
        }

        return _this7._loadAsFile(path.join(potentialDirPath, 'index'), fromModule, toModuleName);
      });
    }
  }, {
    key: '_buildHasteMap',
    value: function _buildHasteMap() {
      var _this8 = this;

      var promises = this._fastfs.findFilesByExt('js', {
        ignore: function ignore(file) {
          return _this8._isNodeModulesDir(file);
        }
      }).map(function (file) {
        return _this8._processHasteModule(file);
      });

      return Promise.all(promises);
    }
  }, {
    key: '_processHasteModule',
    value: function _processHasteModule(file) {
      var _this9 = this;

      var module = this._moduleCache.getModule(file);
      return module.isHaste().then(function (isHaste) {
        return isHaste && module.getName().then(function (name) {
          return _this9._updateHasteMap(name, module);
        });
      });
    }
  }, {
    key: '_processHastePackage',
    value: function _processHastePackage(file) {
      var _this10 = this;

      file = path.resolve(file);
      var p = this._moduleCache.getPackage(file, this._fastfs);
      return p.isHaste().then(function (isHaste) {
        return isHaste && p.getName().then(function (name) {
          return _this10._updateHasteMap(name, p);
        });
      })['catch'](function (e) {
        if (e instanceof SyntaxError) {
          // Malformed package.json.
          return;
        }
        throw e;
      });
    }
  }, {
    key: '_updateHasteMap',
    value: function _updateHasteMap(name, mod) {
      if (this._hasteMap[name]) {
        debug('WARNING: conflicting haste modules: ' + name);
        if (mod.type === 'Package' && this._hasteMap[name].type === 'Module') {
          // Modules takes precendence over packages.
          return;
        }
      }
      this._hasteMap[name] = mod;
    }
  }, {
    key: '_isNodeModulesDir',
    value: function _isNodeModulesDir(file) {
      var parts = path.normalize(file).split(path.sep);
      var indexOfNodeModules = parts.lastIndexOf('node_modules');

      if (indexOfNodeModules === -1) {
        return false;
      }

      parts = parts.slice(indexOfNodeModules + 1);

      var dirs = this._providesModuleNodeModules;

      if (!dirs) {
        return false;
      }

      for (var i = 0; i < dirs.length; i++) {
        if (parts.indexOf(dirs[i]) > -1) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: '_processFileChange',
    value: function _processFileChange(type, filePath, root, fstat) {
      var _this11 = this;

      // It's really hard to invalidate the right module resolution cache
      // so we just blow it up with every file change.
      this._immediateResolutionCache = Object.create(null);

      var absPath = path.join(root, filePath);
      if (fstat && fstat.isDirectory() || this._ignoreFilePath(absPath) || this._isNodeModulesDir(absPath)) {
        return;
      }

      if (type === 'delete' || type === 'change') {
        _.each(this._hasteMap, function (mod, name) {
          if (mod.path === absPath) {
            delete _this11._hasteMap[name];
          }
        });

        if (type === 'delete') {
          return;
        }
      }

      if (extname(absPath) === 'js' || extname(absPath) === 'json') {
        this._loading = this._loading.then(function () {
          if (path.basename(filePath) === 'package.json') {
            return _this11._processHastePackage(absPath);
          } else {
            return _this11._processHasteModule(absPath);
          }
        });
      }
    }
  }]);

  return DependencyGraph;
})();

function extname(name) {
  return path.extname(name).replace(/^\./, '');
}

function resolutionHash(modulePath, depName) {
  return path.resolve(modulePath) + ':' + depName;
}

function NotFoundError() {
  Error.call(this);
  Error.captureStackTrace(this, this.constructor);
  var msg = util.format.apply(util, arguments);
  this.message = msg;
  this.type = this.name = 'NotFoundError';
  this.status = 404;
}

function normalizePath(modulePath) {
  if (path.sep === '/') {
    modulePath = path.normalize(modulePath);
  } else if (path.posix) {
    modulePath = path.posix.normalize(modulePath);
  }

  return modulePath.replace(/\/$/, '');
}

util.inherits(NotFoundError, Error);

function UnableToResolveError(fromModule, toModule, message) {
  Error.call(this);
  Error.captureStackTrace(this, this.constructor);
  this.message = util.format('Unable to resolve module %s from %s: %s', toModule, fromModule.path, message);
  this.type = this.name = 'UnableToResolveError';
}

util.inherits(UnableToResolveError, Error);

module.exports = DependencyGraph;